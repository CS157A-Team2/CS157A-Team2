\documentclass[letter, 12pt, titlepage]{article}
\usepackage{graphicx}
\setlength{\parindent}{0pt}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{wrapfig}

\author{
	Dispoto, Brett\\
        \and
        Kamel, Adham\\
        \and
        Cai, Feiyu\\
}


\title{CS157A Team 2 \\ Final Report\\
        \large A Book Reading and Review Web Application | "OpenBooks"}

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{CS157A Team 2}
\rhead{Final Report, page \thepage}
\cfoot{Brett Dispoto, Feiyu Cai, Adham Kamel}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}



\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Project Requirements}
\subsection{Project Description}
\subsubsection{Application Overview}
Our team will be developing a database application where users can find free books and are able to download them via multiple formats and leave reviews on those books for other customers to see. The books that the user can see will be ranging from textbooks to novels. A user will be given the option to create an account, or if they already registered, login to their account. After this, the user will be able to search for a specific book, whether that is by the title of the book or its ISBN number. If the user does not know the specific book they want to find, they can search for a specific author, or genre. Searches will include various filtering options such as date published, publisher, book length, user favorites, etc. Users can sort search results by the title alphabetically, the author alphabetically, or by book rating.

\medskip
In our application, users will be able to leave reviews on books that they have read, which will be seen by other users and possibly influence their decision on their book. These reviews will contain both a comment subsection and a star rating system. Users will be able to comment how they either liked or disliked the book and give a star rating from one to five. The average star rating and total number of reviews will be displayed next to the book. Users will also be able to share the book they like with others with a shareable link that they can distribute how they please.
\subsubsection{Project Motivation}
The motivation behind this project is that as college students, we find ourselves paying several hundreds of dollars on college textbooks alone every semester, only to have them sitting on a shelf afterwards not being opened. Those hundreds of dollars spent on semester long textbooks could have been better utilized for students on other needs such as groceries or rent. We want to make a website to give students that option, giving them a website where they can download their desired textbooks for free.
\subsubsection{Project Goal}
The Goal of this project is to provide a free and open source infrastructure where users can read books from the public domain. We wish to provide an easy-to-use ecosystem, which allows the user to read or review books with ease.
\subsubsection{Benefits to Users}
Users will have a community where they can \textbf{read and review books for free}. Right now, websites such as this exists, but they only serve one of the two desired functionalities. Websites like gutenberg.org give the users access to free book repositories, but do not allow for users to read and write reviews on books. Conversely, websites like bookpage.com provide reviews for books, but they do not provide free access to such books. Our web application will take the best aspects of both these websites to provide the user an efficient solution for picking and reading online books for free.
\subsubsection{Stakeholders and Importance}
The stakeholders of our applications will be students who want to find free textbook alternative to the paid bookstore alternative, as well as casual and dedicated book readers who can find free books online and download them for instant reading. This application is important because it provides a streamlined way for book-readers to gain easy access to the books they want and get them in a timely manner.


\subsection{System Environment}

\includegraphics[scale=.66]{3-tier.png}
\subsubsection{Presentation Layer}
\begin{itemize}
	\item HTML
	      \begin{itemize}
		      \item Purpose: HTML is the markup language supported by all major web-browsers. It allows content to be presented to a readable manner to the end-user. We will take advantage of HTML formatting tools such as hyperlinks, tables, and lists. Further, we will be using HTML forms for user input of email, username, password, search boxes, and comments.
		      \item Version: HTML 5
	      \end{itemize}
	\item Cascading Style Sheets (CSS)
	      \begin{itemize}
		      \item Purpose: CSS will be used to improve the user experience of our web application. CSS gives us the ability to make animations, colored content, as well as more control of the appearance of our content.
		      \item Version: CSS 3
		      \item Framework: Bootstrap
	      \end{itemize}
	\item	JavaScript (Client Side):
	      \begin{itemize}
		      \item	Purpose: Provide interactivity such as collection of user input, improve visual responsiveness, and sending alerts to users.
		      \item Version: ECMA2016
	      \end{itemize}
\end{itemize}

\subsubsection{Application Layer}
\begin{itemize}
	\item Web Server: Node.js HTTP Module

	      -Version: 10.6.3 LTS

	\item Server Side Application Language: JavaScript

	      -Purpose: Provide commination between the presentation layer and the database layer
	      -Version: EMCAScript 2016

	\item	NPM Package Manger:

	      -Purpose: Provide easy managment of external Node.js libraries such as express js, sql module, connect module, and http module.

	      -Version: 6.9.0
\end{itemize}
\subsubsection{Data Layer}

\begin{itemize}

	\item	This web application will require the use of a relational database management system (RDBMS), the specific RDBMS we will use is  MySQL.
	\item We will take advantage of the SQL programming language for tasks such as data definition, manipulation, query, control,and transaction control.
	\item MySQL RDBMS will take care of concurrency control, and will maintain the ACID principle for our database.
	\item MySQL Version: 5.7.27
	\item Query Language: SQL
\end{itemize}
\subsubsection{Hardware/ Software Used}

\begin{itemize}

	\item Client Software Requirements
	      \begin{itemize}
		      \item A web browser supporting the following is required to run the web application:
		            \begin{itemize}
			            \item ECMAScript2016
			            \item HTML5
			            \item CSS3
		            \end{itemize}
		      \item Since the 3-tier architecture will only be virtual, (no remote web server or DMBS), the client will be required to install the proper versions of Node.js as well as MySQL as specified.

		      \item  MySQL and Node.js are available on many operating systems such as Linux, MacOS, Microsoft Windows, FreeBSD, and OpenBSD
	      \end{itemize}

	\item Client Hardware Requirements:
	      \begin{itemize}
		      \item Any hardware with support by the above software will be sufficient to run the web application.
	      \end{itemize}
\end{itemize}


\subsection{Functional Requirements}
Because this application is to be accessed from a web browser, the \textbf{input} is a keyboard or mouse, while the \textbf{output} is stylized HTML to be displayed on a web browser.

\subsubsection{Comprehensive List of Features}
\begin{itemize}

	\item	Search Book:
	      \begin{itemize}
		      \item  Users can search for books that on the system database
		      \item  Input: ISBN, author, or title
		      \item  Output: list of books that match with the input information
	      \end{itemize}
	\item	Order Search Results:
	      \begin{itemize}
		      \item  User can order the book search results. Default search behavior is based on the number of favorites a book has received
		      \item  Input: relese date or number of favorites
		      \item  Output: ordered list of book that has characteristic from input
	      \end{itemize}
	\item	Filter Search Results:
	      \begin{itemize}
		      \item  User can filter the search reslts
		      \item  Input: release date or genre
		      \item  Output: filtered list of book that matched with characteristic from input
	      \end{itemize}
	\item	Select Book:
	      \begin{itemize}
		      \item  Once user finds the desired book, they can select the book and view its profile.
		      \item  Input: selecting single book
		      \item  Output: book profile that includes book information and comments
	      \end{itemize}
	\item	View Book Profile:

	      A book's profile will consist of the following:
	      \begin{itemize}
		      \item The title of the book,
		      \item The author,
		      \item the relase date,
		      \item the publisher,
		      \item the ISBN,
		      \item the reviews/comments left for the book,
		      \item the number of "favorites" the book has received
	      \end{itemize}
	\item Read/Download Book:
	      \begin{itemize}
		      \item  User can download the book and view it in their web browser.
		      \item  Input: selecting single book
		      \item  Ouput: reading page or download to local
	      \end{itemize}
	\item Add/delete book to/from favorites:
	      \begin{itemize}
		      \item  Use can add the list to their "favorites", indicating that they enjoyed the book
		      \item  Input: selecting single book
		      \item  Output: add/delete book to/from the favorited book list that can be viewed on user's profile
	      \end{itemize}
	\item  View Favorites  \textbf{requires login}:
	      \begin{itemize}
		      \item  User can browse their list of favorited books, with the same sorting/filtering mechanisms as noted above
		      \item  Input: Click view favorite book list in user profile
		      \item  Ouput: list of books that users marked as favorite
	      \end{itemize}
	\item Leave Book Review \textbf{-requires login}:
	      \begin{itemize}
		      \item  Users can leave comments on the profiles of certain books
		      \item  Input: comments that relating to the selected book
		      \item  Output: comments added to the book's repository
	      \end{itemize}
	\item Register as User:
	      \begin{itemize}
		      \item  User can register for an account if they want to have the ability to comment and favorite books
		      \item  Input: user information includes username, password, email
		      \item  Output: user' account created
	      \end{itemize}
	\item Login as User:
	      \begin{itemize}
		      \item  Once registered, users will have the ability to login using the credentials they have provided during registration
		      \item  Input: email and password
		      \item  Ouput: login successfully give the access to login user's profile
	      \end{itemize}
	\item Go to home page:
	      \begin{itemize}
		      \item  The homepage will have information about the website and recent news regarding the website
		      \item  Input: clicked website logo on navigator bar
		      \item  Output: redirect user to homepage
	      \end{itemize}
	\item View profile \textbf{-requires login}:
	      \begin{itemize}
		      \item  All profiles are anonymous because this is \textbf{not a social network}. Users are not allowed to change their username.
		      \item  Input: successfully login
		      \item  Output: Profile page includes username and email information, favorites book list
	      \end{itemize}
	\item Log out:
	      \begin{itemize}
		      \item  login user exits login condition, become vistor to the website
		      \item  Input: login user clicks "Log Out" button
		      \item  Output: becomes vistor and no longer has access to profile page, return to homepage if logout successfully
	      \end{itemize}

\end{itemize}


\subsection{Non-Functional Issues}

\subsubsection{Graphical User Interface}
The Graphical interface of the system will have the following qualities: attractiveness, usability, and responsiveness
\subparagraph{Attractiveness}
The GUI will have a color palate which makes the system attractive to users. We will use high quality fonts and images where applicable. The GUI as a whole will have a coherent and consistent theme.
\subparagraph{Usability}
The GUI will be intuitive. Users will not have to read documentation on how to use the system in order to use it. Options available to the user will be kept to a minimum as to encourage simplicity.
\subparagraph{Responsiveness}
Users will be aware that their requests have been recorded. For example, a user clicks a button, there will be an indication that the button has been successfully clicked, such as a change in color. We will keep bloat to a minimum, such as animations and videos, as to encourage responsiveness for older hardware.

\subsubsection{Security}
\subparagraph{User Security}
To protect user data and privacy, users entities will have the following attributes:
\begin{itemize}
	\item A unique username
	\item A password, required to follow the minimum standards set by the system: which is a minimum of 8 characters, 1 uppercase character, 1 lowercase character, 1 numerical character, and 1 special character
\end{itemize}

\subparagraph{SQL Injection Protection}
To protect form SQL injections, we will take precautions to inspect all user input and escape any characters which could breach security.

\subparagraph{Encryption}
Any sensitive information collected from users will be encrypted fields in the relational database. All passwords will be hashed and we will take advantage of MySQL's build in password functionality.

\subparagraph{Anonymity}
When a user makes a comment, \textbf{only their username will show up}, not their real name. Anonymity protects users from being identified against their will, and prevents personal attacks or blackmail. Users on this web application should be allowed to enjoy and review any books they like, and not have to be worried about ramifications.

\subsubsection{Concurrency Control}
The Relational Database Management System (RDBMS), MySQL, will take care of all needs relating to concurrency control. From the user's perspective, all transactions can be made concurrently.

\subsubsection{Access Control}

\subparagraph{Types of Users}
\begin{itemize}
	\item \textbf{User}
	      Users will only have read access to the following:
	      \begin{itemize}
		      \item  Their own account profile
		      \item  Book repositories with open access
	      \end{itemize}


	      In addition, users will have write access to the following:
	      \begin{itemize}
		      \item  Their own account profile information
		      \item  Their favorites list
		      \item  Their downloads list
		      \item  Reviews for books
	      \end{itemize}

	\item \textbf{Administrator}
	      Administrators have access \textbf{all user functionality} plus extra permissions to data which is not available to the general public. Admins have the following additional privilege:
	      \begin{itemize}
		      \item Delete comments/reviews by users
	      \end{itemize}
\end{itemize}



%------------------------------------------------------------------------Database stuff ----------------------------------------------

\section{Database Project Design}

\subsection{Updated Entity-Relationship Diagram}
\includegraphics[scale=1]{erd-rev.png}
\subsection{Database Schema}
\begin{itemize}
	\item Users(\underline{user\_id}, username, use\_type)
	\item Reviews(\underline{user\_id}, \underline{content\_id}, rating, user\_comment)
	\item Favorites(\underline{user\_id}, \underline{content\_id})
	\item Downloads(\underline{user\_id}, \underline{content\_id})
	\item Content(\underline{content\_id}, title, publish\_date, content\_type)
	\item Article(\underline{content\_id}, author, publication\_name)
	\item Magazine(\underline{content\_id}, issueNum)
	\item Book(\underline{content\_id}, ISBN, author, genre, publisher)
	\item Newspaper(\underline{content\_id}, locale)
	\item Poem(\underline{content\_id}, poem\_type, author)
\end{itemize}

\subsection{Entities}
\subsubsection{Users}
Users are defined as those who have a valid account login for the website.

The attributes for Users are as follows:
\begin{itemize}
	\item user\_type: A user can be of two types, admin or regular. Admins have special privileges
	\item username: The unique username by which a user logs into the web application
	\item user\_id: the unique identifier by which a user's information is tracked
\end{itemize}
\subsubsection{Content}
Content comes in many forms. There are four subclasses of Content, but it possible that there exist an item that is only classifiable as Content and none of its subclasses.

The attributes for Content are as follows:
\begin{itemize}
	\item content\_id: The unique content identifier
	\item title: The name/title of the content
	\item publish\_date: The date the content was published, if available
	\item content\_type: the type of content, if applicable.
\end{itemize}
\subsubsection{Books}
Books are a special case of Content. They have special attributes which sets them apart; however, books inherit the primary key from content. In addition, books have the following attributes:
\begin{itemize}
	\item ISBN: the unique book ISBN number
	\item publisher: the publisher of the book
	\item author: The author of the book
	\item genre: the genre of the book
\end{itemize}
\subsubsection{Magazines}
Magazines are a special case of Content. They have special attributes which sets them apart; however, magazines inherit the primary key from content. In addition, magazines have the following attributes:
\begin{itemize}
	\item issueNum: the issue number of the magazine.
\end{itemize}
\subsubsection{Newspapers}
Newspapers are a special case of Content. They have special attributes which sets them apart; however, Newspapers inherit the primary key from content. In addition, magazines have the following attributes:
\begin{itemize}
	\item locale: the locality of a Newspaper, if available.
\end{itemize}
\subsubsection{Articles}
Articles are standalone pieces of writing which may, in some cases, be significant enough to publish on the web application as it's own piece of media. Articles inherit the primary key from Content but have additional relationships, as described in the relationships subsection. Articles also have the following additional attributes:
\begin{itemize}
	\item author: the author of the article
	\item publication\_name: the name of the publication where the article is from.
\end{itemize}
\subsubsection{Poems}
Poems are a specialized form of content, usually artistic in nature. Poems inherit the primary key from Content but have additional attributes, as described in the relationships subsection. Articles also have the following additional attributes:
\begin{itemize}
	\item author: the author of the poem (if available)
	\item poem\_type: the type of poem (ballad, epic, prose, haiku, etc.)
\end{itemize}

\subsection{Relationships}
\subsubsection{User Reviews Content}
A user (admin or regular) is the author of zero or many reviews on zero or many pieces of content.

The attributes for Reviews are as follows:
\begin{itemize}
	\item rating: a star rating between 1 and 5
	\item user\_comment: a comment about the piece of content (optional)
\end{itemize}
\subsubsection{User Favorites Content}
A user can favorite content, which allows them to keep track of their favorite items. Content can be favorited by zero or many users. Users can favorite zero or many pieces of content.
\subsubsection{User Downloads Content}
We would like to keep track of user's download history. A user can download zero or many pieces of content, and a piece of content may be downloaded by zero or many users.

\subsection{Boyce Codd Normal Form (BCNF) Proofs}
\subsubsection{Users | BCNF Proof }


\textit{Claim: the Users relation is in BCNF}


\begin{proof}


	The relational schema for for the \textbf{Users} table is:


	$ Users(user\_id, user\_type, username) $


	The minimal cover of the functional dependencies for Users is:


	$ user\_id \rightarrow user\_type, username $


	Now, we have to check if $user\_id$ is a superkey, because it is the left side of our only functional dependency.


	Computing the closure of $user\_id$, we find that...

	$user\_id+ = \{user\_id, username, user\_type\}$

	Which means that $user\_id$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Users \in BCNF $
\end{proof}

\subsubsection{Reviews | BCNF Proof }


\textit{Claim: the Reviews relation is in BCNF}


\begin{proof}


	The relational schema for for the \textbf{Reviews} table is:


	$Reviews(user\_id, content\_id, user\_comment, rating)$


	The minimal cover of the functional dependencies for Reviews is:


	$ user\_id, content\_id \rightarrow user\_comment, rating $


	Now, we have to check if the set of attributes  $\{user\_id, content\_id\}$ is a superkey, because it is the left side of our only functional dependency.


	Computing the closure of $\{user\_id, content\_id\}$, we find that...

	$\{user\_id, content\_id\}+ = \{user\_id, content\_id, user\_comment, rating\} $

	Which means that $\{user\_id, content\_id\}$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Reviews \in BCNF $
\end{proof}


\subsubsection{Favorites | BCNF Proof }



\textit{Claim: the Favorites relation is in BCNF}


\begin{proof}


	The relational schema for for the \textbf{Favorites} table is:

	$Favorites(user\_id, content\_id)$

	There are no non-trival Functional Dependencies in this relation, so it is true that for all non-trivial FD's $\in$ Favorites (none), the left side of the FD is a superkey.

	$\therefore Favorites \in BCNF $


\end{proof}
\subsubsection{Downloads | BCNF Proof }


\textit{Claim: the Downloads relation is in BCNF}


\begin{proof}

	The relational schema for for the \textbf{Downloads} table is:

	$Downloads(user\_id, content\_id)$

	There are no non-trival Functional Dependencies in this relation, so it is true that for all non-trivial FD's $\in$ Downloads (none), the left side of the FD is a superkey.

	$\therefore Downloads \in BCNF $

\end{proof}

\subsubsection{Poem | BCNF Proof }

\begin{proof}


	The relational schema for for the \textbf{Poem} table is:


	$Poem(content\_id, poem\_type, author)$


	The minimal cover of the functional dependencies is:


	$ content\_id \rightarrow poem\_type, rating $


	Now, we have to check if the attribute $content\_id$ is a superkey, because it is the left side of our only functional dependency.


	Computing the closure of $\{content\_id\}$, we find that...

	$\{content\_id\}+ = \{content\_id, author, poem\_type \} $

	Which means that $\{content\_id\}$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Poem \in BCNF $
\end{proof}

\subsubsection{Content | BCNF Proof }

\begin{proof}


	The relational schema for for the \textbf{Content} table is:


	$Content(content\_id, content\_type, title, date\_published)$


	The minimal cover of the functional dependencies is:


	$ content\_id \rightarrow content\_type, title, date\_published $


	Now, we have to check if the attribute $content\_id$ is a superkey, because it is the left side of our only functional dependency.


	Computing the closure of $\{content\_id\}$, we find that...

	$\{content\_id\}+ = \{content\_id, content\_type, title, date\_published  \} $

	Which means that $\{content\_id\}$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Content \in BCNF $
\end{proof}

\subsubsection{Magazine | BCNF Proof }

\begin{proof}


	The relational schema for for the \textbf{Magazine} table is:


	$Magazine(content\_id, issueNum)$


	The minimal cover of the functional dependencies is:


	$ content\_id \rightarrow issueNum $


	Now, we have to check if the attribute $content\_id$ is a superkey, because it is the left side of our only functional dependency.


	Computing the closure of $\{content\_id\}$, we find that...

	$\{content\_id\}+ = \{content\_id, issueNum  \} $

	Which means that $\{content\_id\}$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Magazine \in BCNF $

\end{proof}

\subsubsection{Article | BCNF Proof }

\begin{proof}


	The relational schema for for the \textbf{Artcile} table is:


	$Article(content\_id, author, publication\_name)$


	The minimal cover of the functional dependencies is:

	$ content\_id \rightarrow author, publication\_name $


	Now, we have to check if the attribute $content\_id$ is a superkey, because it is the left side of our only functional dependency.


	Computing the closure of $\{content\_id\}$, we find that...

	$\{content\_id\}+ = \{content\_id, author, publication\_name \} $

	Which means that $\{content\_id\}$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Article \in BCNF $

\end{proof}



\subsubsection{Newspaper | BCNF Proof }

\begin{proof}


	The relational schema for for the \textbf{Article} table is:


	$Newspaper(content\_id, locale)$


	The minimal cover of the functional dependencies is:

	$ content\_id \rightarrow locale $

	Now, we have to check if the attribute $content\_id$ is a superkey, because it is the left side of our only functional dependency.

	Computing the closure of $\{content\_id\}$, we find that...

	$\{content\_id\}+ = \{content\_id, locale \} $

	Which means that $\{content\_id\}$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Newspaper \in BCNF $

\end{proof}

\subsubsection{Book | BCNF Proof }
\begin{proof}


	The relational schema for for the \textbf{Book} table is:


	$Book(content\_id, ISBN)$

	The minimal cover of the functional dependencies is:

	$ content\_id \rightarrow ISBN, author, publisher, genre $

	Now, we have to check if the attribute $content\_id$ is a superkey, because it is the left side of our only functional dependency.

	Computing the closure of $\{content\_id\}$, we find that...

	$\{content\_id\}+ = \{content\_id, ISBN, author, publisher, genre\} $

	Which means that $\{content\_id\}$ is a superkey, so the only non-trivial functional dependency in the minimal cover of FDs for this relation does \textbf{not} violate BCNF

	$\therefore Book \in BCNF $

\end{proof}


\subsection{Database Table Instances}
\subsubsection{Users}
\includegraphics[scale=.5]{users.png}
\subsubsection{Reviews}
\includegraphics[scale=.5]{reviews.png}
\subsubsection{Favorites}
\includegraphics[scale=.5]{favorites.png}
\subsubsection{Downloads}
\includegraphics[scale=.5]{downloads.png}
\subsubsection{Poem}
\includegraphics[scale=.45]{poem.png}
\subsubsection{Content}
\includegraphics[scale=.6]{content.png}
\subsubsection{Magazine}
\includegraphics[scale=.5]{magazine.png}
\subsubsection{Article}
\includegraphics[scale=.5]{article.png}
\subsubsection{Newspaper}
\includegraphics[scale=.5]{newspaper.png}
\subsubsection{Book}
\includegraphics[scale=.5]{book.png}

\section{Implementation}

\subsection{Implementation Overview}
	On the server, our project uses the Node.js runtime environment and express.js framework for routing and  http requests/ responses. Each HTML page is implemented using EJS (Embedded JavaScript) as a templating engine. 

	Here is a general overview of how the application works:
	\begin{itemize}
		\item The server is initialized, this includes:
			\begin{itemize}
				\item Claiming the 8080 port of local host using express.js | app.listen()
				\item Establishing a database connection, using the Node.js MySQL module 
					
					| mysql.createConnection(JSON obj)
				\item Defining where all static content is located  (files, photos, etc), using express.js
					
					| express.static(/path/to/static/content)
				\item Initializing all routes/ modules, such as content, auth, and search
			\end{itemize}
		\item HTTP requests from the client trigger various database operations such as INSERT and SELECT, which are executing using the MySQL module function database.query(string sql\_code, function callback). Database.query() is an asynchronous function, meaning that there is no guarantee that it will be executed immediately upon calling it. For this reason, we often must wrap our server HTTP responses in the callback function, assuming we want to use data in our webpages which we have just queried.
		\item Dynamic content queried from the database is then served using EJS templates.
			EJS allows us to embed server-like JavaScript code into our HTML code. 
			The templating engine then truncates the js/HTML hybrid into proper HTML code for the browser to parse.
	\end{itemize}
\newpage
\subsection{Detailed Use-case Implementation}



	\subsubsection{Use Case: Create Account}
For account creation, we use Google Firebase for storing and validatig user credentials. Once we extract the user information from the HTML form, we use the firebase.auth function, createUserWithEmailAndPassword(). If a user is sucessfully created, we can then extract the unique user ID which firebase provides us to store the user in our own MySQl bookstore.User table. Firebase ensures proper password encryption. 


	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.50]{create-account.png}
		\caption{client's perspective: user creating account}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.50]{create-account-code.png}
		\caption{Server: user creating account | code}
	\end{figure}


\newpage
	
	\subsubsection{Use Case: Log In}
For account log in, we use Google Firebase for storing and validatig user credentials. Once we extract the email and password from the HTML form, we use the firebase.auth function, signInWithEmailAndPassword(). If a user successfully logs in we can then extract the unique user ID which firebase provides us to retrieve information abut the user in our MySQL database. Upon login, the user is redirected to the homepage using the express.js function response.redirect(string path).

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.50]{login.png}
		\caption{client's perspective: user logging in}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.50]{login-code.png}
		\caption{Server: user logging in | code}
	\end{figure}

\newpage

	\subsubsection{Use Case: Search for Content}
To search for a book, user use the search bar found at the header of each page. Search queries are done via a HTTP POST request, which sends data from client to server. Once the server receives the POST request, it queries the database for the search term. Users are able to search by author, title, publisher, and more, therefore our SQL query must look check many attributes. For this reason, we use a LIKE clause to ensure that non-exact matches are still found, by using wildcard (\%) operators. Once the search results are found, we parse the JSON provided by the MySQL module, format it into an HTML table, then send the HTML to the EJS templating engine. Once the search is executed, users can decide if they want the results to be ordered.



	\begin{figure}[h!]
		\includegraphics[scale=0.4]{search-results.png}
		\caption{client's perspective: search results}
	\end{figure}


	\begin{figure}[h!]
		\includegraphics[scale=0.40]{search-code.png}
		\caption{Server: searching through content/poem/book/magazine/newspaper/article tables}
	\end{figure}

\newpage

	
	\subsubsection{Use Case: View Profile}
Once logged in, users can view their profile. Users view their profile by clicking the "Profile" link on the top right of the header. A users profile shows the content they've downloaded and favorited. To find the books which a user has favorited/downloaded JOIN the Users/Downloads tables and the Users/Favorties tables; in both cases we JOIN using the user\_id as the attribute to join on.

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.40]{profile.png}
		\caption{client's perspective: user profile}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.4]{profile-code.png}
		\caption{Server: user profile | code}
	\end{figure}

\newpage

	
	\subsubsection{Use Case: Sorting Results}
	Where applicable, the user can sort results of various content. Content is sorted in several contexts. For example, when a user clicks "search" or "browse all content", the available sort options are  title, content type, rating, number of downloads, number of favorites, or average rating. When specific content is being displayed, more options are available. For example, when a user is viewing the Poems page, they can sort by poem type or author. Books can be sorted by author, genre, publisher. Newspapers can be sorted by date or location. Articles can be sorted by author or publication. Magazines can be sorted by issue number. All content can be sorted by title.

	Sorting is implemented using HTTP GET requests. For example, when is a user is on the Books page, and they click "Sort by Title", they are redirected to the URL /books/title. We then re-render the page, this time displaying the results, this time using an SQL ORDER BY clause.

\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.33]{sort.png}
		\caption{client's perspective: sorting results}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.33]{sort-code.png}
		\caption{Server: user profile | code}
	\end{figure}

\newpage


\subsubsection{Use Case: View Content Profile}
	If a user is interesting in learning more about a piece of content, they can view the content's profile. The content profile contains extra information about the content such as when it was published, the publisher, the average rating, the number of favorites/downloads, and more. On the server, we query the database to find more information on the content the user is requesting. The user requests the content using an HTTP GET request. When a user clicks on a particular piece of content, first they are redirected to a URL which such as \$CONTENT\_TYPE/\$CONTENT\_ID. From there, we find extra information about the content depending on its subclass, then send all necessary information and redirect to /content-profile.
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.25]{content-profile.png}
		\caption{client's perspective: viewing content profile}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.32]{content-profile-code.png}
		\caption{Server:  querying database for content information}
	\end{figure}

\newpage




\subsubsection{Use Case: Write Review}
	Once logged in, users can add reviews for content. A review does not require a comment, but does require a rating. Reviews are implemented using HTML forms and HTTP POST requests. The server inserts the data directly from the form into the MySQL bookstore.Reviews table. 
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.43]{review.png}
		\caption{client's perspective: writing review}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.42]{review-code.png}
		\caption{Server: insert reviews}
	\end{figure}

\newpage


\subsubsection{Use Case: Read Review}
	On the content profile, we display all reviews left for the content. We get this data using a sequence of simple SELECT and JOIN statements. We format the JSON output from the MySQL Node.js module into HTML divisions to make the review more visually appealing.
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.45]{read-review.png}
		\caption{client's perspective: reading a review}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.67]{read-review-code.png}
		\caption{Server: selecting review from database}
	\end{figure}

\newpage


\subsubsection{Use Case: Favorite/ Download Content}
	Once logged in, users can favorite or download any content. Users can "undo" a favorite but cannot "undo" a download. On the top of each content page, there are two buttons: Favorite and Download. These are actually HTML links which redirect to URLs indicating we need to add/remove a favorite or add a download to/from its appropriate table. Once a user "favorites" a content, the "favorite" button on top of the page becomes a "remove favorite" button. This is accomplished using the EJS templating system, we make a simple statement that says if the user has favorite this  content, show a different button (unfavorite).
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.30]{favdl.png}
		\caption{client's perspective: downloading/ favoriting content}
	\end{figure}
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.30]{unfav.png}
		\caption{client's perspective: un-favoriting content}
	\end{figure}
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.45]{favdl-code.png}
		\caption{Server: inserting favorites/ downloads into their tables}
	\end{figure}

\newpage





\subsection{Project Setup/ Configuration}
	To set up the project, follow these steps:
	\begin{enumerate}
		\item Download + install MySQL
		\item Download + install Node.js
		\item Clone the repository https://github.com/CS157A-Team2/CS157A-Team2
		\item Set up MySQL to allow remote access.
		\item Set the MySQL root password to 'root'
		\item cd to PATH/TO/PROJECT/src/model/ then login to MySQL command line using 'mysql -u root -p' then run the following commands:
				\begin{enumerate}
					\item 'source init.sql'
					\item 'source loaddata.sql'
					\item confirm success by typing 'source queryAll.sql'
				\end{enumerate}
		\item cd to  PATH/TO/PROJECT/src/web-server/ then run 'node server.js'
		\item go to your web browser (while the node process is running) and go to http://localhost:8080
		\item email brett.dispoto@sjsu.edu if any issues arise
	\end{enumerate}

\section{Project Conclusion}

\subsection{Lessons from Project | Teammate Statements}

\subsubsection{Brett Dispoto}
Prior to working on OpenBooks, I had no knowledge of practical database design/ application development. I now understand the following:
\begin{itemize}
	\item The importance of an E/R design and analysis \textbf{prior} to implementing the relational schemas in the DBMS. Because our group put a large amount of work into our relational schema design, the normalization process into BCNF was extremely minimal.
	\item How to perform database integration on a virtualised 3-tier architecture. This includes
	      \begin{itemize}
		      \item How to install and configure a local MySQL server, allowing remote access.
		      \item How to use Node.js to perform MySQL database queries, then parsing the JSON output of those queries.
		      \item How to install and configure the MySQL Node.js module.
	      \end{itemize}
	\item How to use embedded javascript (EJS) to display dynamically generated content using data from a MySQL database.
	\item How to write SQL (DDL/DML) scripts for automated database setup.
	\item How to effectively work as a team, where the responsibilities include writing functional specifications,  designing database schemas, and implementing a database application.
\end{itemize}
\subsubsection{Feiyu Cai}
Working on OpenBooks, gives me a opportunity that apapplying what I have learned about database design and management on real life application. In fact, there are some specific area I had practiced in this project: 
\begin{itemize}
	\item I have learned converting a E/R diagram of database to database table in practice. We spent 1/3 of the class time discussed about E/R diagram and converting it into table for these project. For the amount of table we used in this project, I had a great pratice how the conversion works and have better understand of relational database
	\item I have learned normalization of database. I had used a lot of NoSQL database in the past because normalization was painful for me. Errors sometime were caused by deleting something in the database. In this project, I have a lot of pratice about normalizing database into smaller table to aviod errors and bugs happen.
	\item This is my first time working with relational databse with Node.js. Writing sql query with javascript syntax is first time for me. 
	\item Writing sql file and importing it with sql CL tools is useful and convenience while inputing large amount of data.
	\item Learning to use MySQLWorkBench for virtualising database is useful when having multiple tables.
	\item Communicate with teammates and collaborate on Github makes working together easier.  
\end{itemize}
\subsubsection{Adham Kamel}

\subsection{Future Improvements | Discussion}
A \textit{wishlist} of future improvements for this project would be as follows:
\begin{enumerate}
	\item Deploying the database/ middleware on a remote server, eliminating the virtualised 3-tier architecture we are currently running on in favor of a proper client-server-database architecture. This would allow OpenBooks to be accessed on the web, rather than having to manually install, configure, and deploy on the client's local machine.
	\item Adding advertisements | the data stored in our tables would be valuable to advertising firms running targeted advertisements. Information such as \textit{"John Doe likes to read the new york times on Tuesday afternoons"} is very useful to such firms, and the revenue gained could be used to help OpenBooks achieve  goal (1) above.
	\item Add more tables to track user data such as average session time.
	\item Add more features / customizability user profiles |  such as profile photos, following users, view other user's profile.
	\item Email notification system | When a new book is released by an author of which a user has favorited their book, the user should receive an email notification.
	\item Look into the possibility of having tables be 4NF/5NF.
	\item A terms of service, copyright licence, and privacy policy.
\end{enumerate}
\end{document}
